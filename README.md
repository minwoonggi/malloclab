### 프로젝트를 시작하게된 계기

C언어는 프로그래머가 메모리를 직접 할당하고 해제해야 합니다. 만약 동적으로 메모리를 할당하지 않을 시에는 정적으로 메모리를 선언해야 하는데 정적으로 할당된 메모리는 프로그램이 종료될 때까지 메모리를 점유합니다. 따라서 메모리 사용량이 예측 가능하지 않고, 크기가 고정되어 있어 유연성이 부족합니다. 또한 그 메모리 사용량을 초과할 경우 메모리 오버플로우가 발생할 수 있습니다.

따라서 C언어를 사용하는 프로그래머라면 동적할당을 사용하여 메모리 관리를 할 수 있어야만합니다. 

C언어의 동적 메모리를 할당하는 함수는 크게 3가지가 있습니다.

1. **malloc(): 메모리를 할당하는 함수로, 필요한 바이트 수를 인자로 받아 할당된 메모리의 시작 주소를 반환합니다.**

```c
void* malloc(size_t size);
```

1. **calloc(): 메모리를 할당하고 모든 비트를 0으로 초기화하는 함수입니다. 할당된 메모리의 시작 주소를 반환합니다.**

```c
void* calloc(size_t num, size_t size);
```

1. **realloc(): 이미 할당된 메모리 영역의 크기를 변경하는 함수입니다. 첫 번째 인자로는 이전에 할당된 메모리의 포인터를 받고, 두 번째 인자로는 새로운 크기를 받습니다.**

```c
void* realloc(void* ptr, size_t size);
```

이 프로젝트는 기본적으로 <stdio.h> 헤더 파일에 선언되어 있습니다.

또한 프로그램이 종료되기 전에 할당한 메모리를 해제하는 함수 가 있스빈다.

**free(): 할당된 메모리의 포인터를 매개변수로 받아 해당 메모리를 해제합니다.** 

```c
void free(void *ptr);
```

위의 함수들의 구조를 분석하고 파악하여 어떤방식으로 동작하는 지 알아내어 직접 함수를 만들어보는 과정을 거친다면 더욱 C언어에 대한 깊이를 쌓을 수 있기 때문에 이 프로젝트를 진행하게 되었습니다.

### 동적 메모리 할당

일단 정적 메모리 할당과 동적 메모리 할당의 차이부터 파악해봅시다. 정적 메모리 할당은 프로그램 컴파일시 **메모리(Stack)**에 얼마만큼의 크기로 할당을 해야하는지 결정되고 할당된 메모리는 프로그램이 실행되는 동안에 고정됩니다. 반면 동적 메모리 할당은 프로그램이 실행 중에 필요에 따라 **메모리(heap)**를 동적으로 할당하고 해제할 수 있습니다. Dynamibc memory allocation 이라 불리며 줄여서 malloc이며 동적 메모리 할당기라고도 말할 수 있습니다.

메모리의 최대 크기는 사용가능한 **가상 메모리의 양**에의해서만 제한됩니다.

**요약**

**정적 → 컴파일시 → 스택에 메모리할당 + 프로그램 종료까지 유지**

**동적 → 런타임시 → 힙에 메모리 할당~>해제**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/98194db6-77fb-4f22-8e55-fb06f5d1f7a7/9d940c3f-7632-491e-871d-93c9d21f5260/Untitled.png)

### 명시적 할당기 vs 묵시적 할당기

- **명시적 할당기**는 할당된 블럭을 명시적으로 해제해줘야 하는 할당기를 말합니다 C의 malloc,free 등
- **묵시적 할당기**는 할당된 블록이 더이상 사용되지 않으면 이를 감지해서 해제해주는 할당기를 말합니다. JAVA의 Garbage Collector등

즉 지금하는 프로젝트는 명시적 할당기를 만드는 것입니다.

### 힙

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/98194db6-77fb-4f22-8e55-fb06f5d1f7a7/46f77420-16bf-4b54-9c72-eae5fce798fc/Untitled.png)

동적 메모리 할당기는 힙이라고 하는 프로세스의 가상 메모리 영역을 관리합니다.  가상 메모리는 쉽게 말해 메모리가 실제 메모리보다 많아보이게 하는 기술입니다. 물리적 메모리 크기의 한계를 극복하기 위해 가상 메모리를 사용하며 이 가상메모리를 물리 메모리로 매핑하는 역할은 운영 체제가 담당합니다.

힙 영역에는 다양한 사이즈의 **할당된 블록(allocated block)과 가용 블록(free block)**들로 이루어져 있습니다.

### 메모리 블록

메모리 블록은 프로그램이 할당한 메모리 영역을 나타내는데 사용됩니다.

**할당된 블록**은 malloc, calloc, realloc 등의 함수를 사용하여 동적으로 할당한 메모리를 나타내며 할당된 블록은 프로그램이 사용하는 실제 데이터를 저장합니다.

**가용 블록**은 할당되지 않은 자유로운 메모리 공간을 나타냅니다. 이전에 할당된 메모리 블록이 해제 되었거나 할당이 된적 없는 메모리 공간을 이죠.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/98194db6-77fb-4f22-8e55-fb06f5d1f7a7/557b3e00-fc5e-4619-9391-60381c33ddd9/Untitled.png)

메모리 할당의 기본 단위는 시스템에 따라 다를 수 있습니다. 대부분의 시스템은 메모리 할당을 위해 최소 단위로 1바이트를 사용합니다. 그러나 메모리 할당자는 일반적으로 메모리를 효율적으로 사용하기 위해 여러 바이트 단위로 메모리를 할당할 수 있습니다.

일반적으로 많은 시스템에서는 4바이트(32비트) 또는 8바이트(64비트)와 같은 크기의 블록을 사용하여 메모리를 할당합니다. 이는 대부분의 데이터 타입이 4바이트 또는 8바이트 정렬되어 있기 때문에 효율적인 메모리 사용을 위한 것입니다.

이 메모리 블록은 일반적으로 다음과 같은 구조를 가집니다.

1. 헤더

할당된 메모리 블록의 메타데이터를 저장합니다. 이 메타데이터에는 블록의 크기, 할당 여부등의 정보가 포함될 수 있습니다. 할당 여부는 3자리 비트로 이루어지며 마지막 비트의 0과 1로 할당과 가용을 구분합니다.

만약 더블 워드(8바이트) 정렬 제약 조건을 설정한다면, 블록 크기는 항상 8의 배수입니다. 즉 블록 크기의 하위 비트는 항상 0이 됩니다.

따라서 블록 크기의 상위 29비트만 저장할 필요가 있으며, 나머지 3비트는 다른 정보를 인코딩하기 위해 남겨둡니다.

이 경우 블록이 할당되었는지 혹은 가용 상태인지를 나타내기 위해 LSB를 사용합니다.

예를 들어 블록 크기 24바이트를 갖는 할당된 블록이 있는 경우, 헤더는 다음과 같이 됩니다.

```c
0x00000018[블록 크기] | 0x1[가용 상태 여부] = 0x00000019
```

블록 크기가 40바이트(x28)을 갖는 가용 블록이 있는 경우,헤더는 다음과 같이 됩니다.

```c
0x00000028[블록 크기] | 0x0[가용 상태 여부] = 0x00000028
```

즉 할당된 블록+1 , 가용 블록+0 인방식으로 LSB가 나타납니다.

1. 데이터

프로그램이 사용하는 실제 데이터를 저장하는 부분입니다.

할당된 블록의 헤더 이후에 위치하며, 실제로 프로그램이 사용하는 데이터가 여기에 저장됩니다.

1. 패딩

메모리 블록 내에서 패딩은 데이터의 정렬을 보장하기 위해 추가된 비어있는 공간을 나타냅니다. 만약 블록의 크기가 다 다르다면 컴퓨터는 모든 블록을 다 따로 계산해야 할 것입니다.

 4. 푸터

일부 메모리 할당자는 블록의 끝에 추가적인 메타데이터를 저장합니다. 이전 블록과 다음 상태를 쉽게 파악할 수 있습니다. 이는 주로 메모리 누수 및 오버런 감지와 같은 목적으로 사용됩니다.

결국 메모리 할당을 위해서는 가용 블록을 찾아서 가용 블록에 대한 포인터를 applicaition에게 반환해주고 해당 가용 블럭을 할당된 블록이 되었다고 기입해 줍니다. 만약 application이 요청하는 사이즈의 free block을 찾을 수 없다면, sbrk 라는 system call을 통해서 시스템으로부터 더 많은 메모리를 할당 받습니다. 이를 통해 적절한 사이즈의 가용 블록을 확보하고, 이에 대한 포인터를 applicaiton에게 반환해줍니다. 참고로 sbrk를 호출하면 아래 그림과 같이 brk pointer를 위로 올리거나 낮춤으로써 heap memory를 증가시키거나 감소시킬 수 있습니다.

### 가용 리스트(free list)

동적 메모리 할당자가 관리하는 자유 블록(가용 블록)의 목록을 나타냅니다. 이는 할당되지 않은, 즉 아직 사용되지 않은 메모리 블록들을 추적하고 관리하기 위해 사용됩니다.

가용 블록들을 일종의 list 형태로 추적 관리하는 방식이 크게 3가지 있는데, implicit free list, explicit free list, segregated free list가 있습니다.

어떤 종류의 가용 리스트를 채택하느냐에 따라 free block format, placing, splitting, coalescing 방식이 모두 달라질 수 있습니다.

### 명시적 가용 리스트

명시적 가용 리스트에서는 가용한 모든 메모리 블록이 따로 관리되며, 이러한 가용리스트는 포인터 구조체 등을 사용하여 명시적으로 관리됩니다.

이 방법은 메모리 할당 및 해제 시 빠르고 정확한 검색을 가능하게 합니다. 하지만 메모리를 관리하는데 있어서 가용 리스트를 유지하기 위한 추가적인 포인터 및 메타데이터가 필요하기 때문에 오버헤드가 발생할 수 있습니다.

### 암묵적 가용 리스트

암묵적 가용 리스트에서는 가용한 메모리 블록과 할당된 메모리 블록이 서로 연결되어 있으며, 메모리 블록의 상태(가용/할당)는 메모리 블록 헤더에 포함됩니다.

이 방법은 가용한 블록의 정보를 유지하기 위한 별도의 포인터나 메타데이터가 필요없어서 오버헤드가 명시적 가용 리스트보다 적습니다. 하지만 메모리 할당 및 해제 작업은 가용한 블록을 찾기 위해 전체 메모리를 순회해야 하기 때문에 더 복잡하고 느릴 수 있습니다.

### 할당할 블록 결정(placing)

어떠한 애플리케이션이 k바이트의 블록을 요청할 때, 할당기는 요청한 블록을 저장하기에 충분히 큰 가용 블록을 리스트에서 검색합니다.

검색을 수행하는 방법은 first fit, next fit, best fit과 같은 배치 정책에 의해 결정됩니다.

**fist fit(최초 할당)**

처음부 검색을 시작하여 맨 처음 크기가 맞는 블록을 선택하는 방법입니다. 따라서 모든 블록의 수에 비례한 시간이 소요됩니다.

리스트의 시작 부분에 작은 파편들이 다수 발생할 수 있습니다. 이때문에 first fit은 리스트의 마지막에 가장 큰 가용 블록들을 남겨두는 경향이 생겨 큰 블록을 찾는 경우에 검색 시간이 늘어날 수 있습니다.

**Next fit(다음 할당)**

first fit과 유사하지만, 이전에 검색이 종료된 위치에서 검색을 시작한다는 점이 다릅니다. first fit에 비해 매우 빠르지만 파편화가 더 심하게 발생합니다.

**Best fit(최적 할당)**

리스트를 검색하여 가장 근접한 크기의 블록을 선택하는 방법입니다.

파편화를 크게 예방가능하지만, 전체 리스트를 탐색하므로 first fit보다는 훨씬 느리게 동작합니다.

### Free 블록의 분할(splitting)

할당기가 할당할 가용 블록을 찾은 후, 가용 블록의 어느 정도를 할당할지에 대해 결정하여야 합니다.

만약 해당 블록이 요청한 사이즈보다 훨씬 클경우 이 블록을 통째로 application에게 주면 낭비가 됩니다. 따라서 분할 하는 과정 또한 고려해야합니다.

한 가지 방법은 해당 가용 블록 전체를 사용하는 것입니다. 이는 빠른 속도를 가지지만, **내부 단편화**가 발생한다는 단점이 있습니다.

예를 들어, 요청된 메모리 크기가 가용 블록의 크기보다 작은 경우에는 블록의 일부가 낭비될 수 있습니다.

다른 방법으로는 가용 블록을 쪼개어, 할당할 블록과 새로운 가용 블록으로 나누는 방법이 있습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/98194db6-77fb-4f22-8e55-fb06f5d1f7a7/ae43488f-5511-463d-b592-70c0727cf192/Untitled.png)

### before

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/98194db6-77fb-4f22-8e55-fb06f5d1f7a7/2d0a3a4c-daea-464a-ae51-0d53218375fd/Untitled.png)

### After

### 가용 블록 통합하기(coaleacsing)

할당한 블록을 반환할 때, 새롭게 반환하는 블록에 인접한 다른 가용 블록들이 있을 수 있습니다. 이러한 인접 가용 블록들은 **외부 단편화**라는 현상을 유발시킬 수 있으며, 이때는 너무 작아서 사용할 수 없는 가용 블록으로 쪼개진 많은 가용 메모리들이 존재합니다

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/98194db6-77fb-4f22-8e55-fb06f5d1f7a7/092c989b-5127-4942-845b-e462348542f3/Untitled.png)

위 그림은 할당한 블록을 반환한 결과를 보여줍니다. 오류 단편화를 극복하기 위한 실용적인 할당기라면 결합(coalescing)이라는 과정을 통해 가용 블록들을 통합해야합니다.

### 내부 단편화와 외부 단편화

단편화(파편화)는 사용가능한 메모리가 여기저기 쪼개져 있어 제대로 활용할 수 없는 현상을 말하며 이 현상이 utilization을 방해하는 요소가 됩니다.

내부 단편화는 할당된 메모리 블록 내에서 발생하는 단편화를 말합니다. 만약 applicaiton이 100바이트를 요청했을 때 128바이트 블록을 할당한 경우, 28바이트는 사용되지 않고 내부 단편화로 남습니다.

외부 단편화는 사용 가능한 총 메모리 공간이 충분하지만, 그 공간이 여러 작은 조각으로 나뉘어 있어서 실제로 필요한 크기의 메모리 블록을 할당할 수 없는 상황을 의미합니다. 여러개의 프로그램이 메모리를 할당받고 해제하는 과정에서 메모리의 빈 공간이 여러 작은 조각으로 나뉘어 필요한 큰 블록을 할당할 수 없는 경우가 발생합니다.

### 동적 할당기 성능

동적 할당기 성능을 측정한느 대표적인 지표는 memory utiliztion과 throughput 입니다. utilizaion은 쉡게 말해 힙 영역을 낭비하는 공간 없이 application이 필요한 데이터를 얼마나 꽉 채워서 썼는가입니다. throughput은 쉽게 말해 얼마나 빨리 application의 allocate/free 요청을 처리해줄 수 있는 가입니다.

이 두 성능 지표는 trade-off 관계에 있기 때문에 적절히 밸런스를 맞추는 것이 중요합니다.

예를 들어 동적할당기는 가용 블록이나 할당된 블록의 bookkeeping정보를 담을 수 있습니다. 할당기는 이들 정보를 적절히 활용하여 요청을 빠르게 처리할 수 있지만 이들 정보는 위에서 application이 저장하 싶은 정보가 아니기 때문에 낭비 공간에 해당하고 utilizion을 갉아 먹습니다.
